#!/usr/bin/env python3
# -*- coding: utf-8 -*-
'''
This class contains methods to CloudyProgram in order to convert
the output to a skirt input.
Consider this file as additional methods for CloudyProgram, as I prefer to
handle conversions between programs as separate files.
This class works with four files generated by runCloudy() method, 
each one is labelled as:
    1) 'composition_zone'
    2) 'overview_zone'
    3) 'tau_zone'
    4) 'spectra_zone'
Also see writeInput() method for more information

Mario Romero            July 2021
'''

import numpy as np
import utils.unkeep as unk

class CloudyToSkirt(object): #I need read_config
    def GenerateSkirtInput(self):
        #Capture Outputs
        extension = ".txt"
        #Get wavelength array (Common for all zones)
        wavelength_array = np.logspace(np.log10(self._wavelength_min),np.log10(self._wavelength_max),self._wavelength_res+1)
        for z in range(0,self._n_zones):
            #Get mean density
            #print(z)
            overview_name = "overview_zone"+str(z)+extension
            composition_name = "composition_zone"+str(z)+extension
            rho = self._meanDensity(overview_name,composition_name)
            M   = self._param_mass[z] #remember, in solar masses
            
            #Get opacities and corrections
            tau_name = "tau_zone"+str(z)+extension
            optical_depth_data = self._getOpacities(tau_name,rho,z,wavelength_array)
            #Get luminosity, and correct it
            spectra_name = 'spectra_zone'+str(z)+extension
            nuLnu = self._getLuminosity(spectra_name, rho, z, wavelength_array)
            #unk.testDownsample(unk.mean(self.__lambda),nuLnu,unk.mean(self.__lambda),nuLnu*optical_depth_data[3])
            tau_shell = optical_depth_data[0]
            #massExtinctionCoeff = optical_depth_data[1]
            #albedo = optical_depth_data[2
            try:
                #Correct for self-absorption.
                nuLnu_corrected = nuLnu * tau_shell / ( 1. - np.exp(-tau_shell) ) #optical_depth_data[3]
                nuLnu = nuLnu_corrected
            except FloatingPointError:
                print("Warning: undeflow encountered in exp(-tau) in zone "+str(z))
                nuLnu_corrected = np.empty(len(tau_shell))
                for t in range(0,len(tau_shell)):
                    exp_order_of_magnitude = -tau_shell[t] / np.log(10.0) # =log10(exp(-tau))
                    if exp_order_of_magnitude <= -250.0:
                        #exp(-tau) = 0, avoid the underflow!
                        nuLnu_corrected[t] = nuLnu[t] * tau_shell[t]
                    else:
                        nuLnu_corrected[t] = nuLnu[t] * tau_shell[t] / ( 1. - np.exp(-tau_shell[t]) )
                nuLnu = nuLnu_corrected
                
            #Find normalization
            # I need two per zone: total optical depth and luminosity
            wv_norm = self._wavelength_norm
            norm_values = unk.findNormalization(wv_norm,unk.mean(wavelength_array),np.array([4.0*tau_shell,nuLnu]))
            #print(norm_values)
            
            #Write the files
            self._writeOpacityFile(z,M,unk.mean(wavelength_array),optical_depth_data[1],optical_depth_data[2])
            #self._writeOpacityFile_tauNormalization(z,[norm_values[0],norm_values[1]],unk.mean(self.__lambda),optical_depth_data[1],optical_depth_data[2])
            self._writeEmissionFile(z,[norm_values[0],norm_values[2]],unk.mean(wavelength_array),nuLnu)
            
            #break #Testing for the first zone only
    
    def _meanDensity(self,overview_name,composition_name):
        #Here we get the density from overview and composition files
        #In this manner, result is not dependent of geometry (the alternative would be Mass/Volume)
        
        #Get depth s
        s   = unk.readColumn(overview_name,0)
        #Get density rho, this is more complex as we have to read rows
        abundances = open(composition_name,'r')
        rho = []
        while True:
            line = abundances.readline()
            if not line: break #EoF
            elif line[0] == '#': continue #Commented line
            
            line_data = line.split()
            ni = np.array([10.**float(line_data[i]) for i in range(0,len(line_data))])
            rho.append(self.mH*np.dot(self.Ai,ni))
        
        abundances.close()
        rho = np.array(rho)
        
        return np.trapz(rho,s) / (s[-1]-s[0]) #Taking the mean of the zone...
    
    def _getOpacities(self,tau_name,rho,zone,wavelengths):
        #Return is [total optical depth, extinction coefficient (cm2/g), albedo]
        #Each element is an array of len = len(self.__lambda) - 1
        #Each element is an array
        
        #get all data
        all_tau_data = np.flipud(unk.readColumn(tau_name,[0,1,3]))
        #Downgrade the data. We conserve the integral of tau in wavelengths
        total_tau = unk.downsample(wavelengths,all_tau_data[:,0],all_tau_data[:,1])
        scatt_tau = unk.downsample(wavelengths,all_tau_data[:,0],all_tau_data[:,2])
        #Get albedo
        albedo = scatt_tau/total_tau
        #Add extinction coefficient
        ds = self._getThickness(zone) * self.pc
        extinction = total_tau / (rho*ds) #MASS extinction coefficient, in cm2/g
        #done
        return np.array([total_tau,extinction,albedo])
    
    def _getLuminosity(self,spectra_name,rho,zone,wavelengths):
        #This returns nu*L_nu (erg/s). It is supposed to have the same
        #wavelengths as extracted before in _getOpacities()
        #This also assumes that cloudy run in the intensity case
        
        #Get emitted spectra
        all_data = np.flipud(unk.readColumn(spectra_name,[0,3]))
        #To make clear what I am using here
        wavelen_data = all_data[:,0]
        FourPi_nuJnu_data = all_data[:,1]
        #Use the wavelengths to degrade the spectra conserving J, not nu*J
        #FourPi_Jlambda = unk.downsample(wavelengths,all_data[:,0],all_data[:,1]/all_data[:,0])
        FourPi_Jlambda = unk.downsample(wavelengths,wavelen_data,FourPi_nuJnu_data/wavelen_data)
        FourPi_nuJnu = unk.mean(wavelengths)*FourPi_Jlambda
        
        #Get luminosity
        ds = self._getThickness(zone) * self.pc
        V  = self._getVolume(rho,zone)
        
        nu_Lnu = FourPi_nuJnu*V/ds #To make clear what I'm returning here
        return nu_Lnu
    
    def _getVolume(self,rho,zone):
        return (self._param_mass[zone]*self.Msun) / rho #in cm3
    
    def _getThickness(self,zone):
        #return thickness in pc
        if self._geometry[zone][0] == 'shell':
            #self._geometry = ['shell',Rin,Rout]
            Rin  = self._geometry[zone][1]
            Rout = self._geometry[zone][2]
            #thickness is the half width of each zone
            return (Rout - Rin)/2.0
        elif self._geometry[zone][0] == 'ring':
            #self._geometry = ['ring',R,w,h]. w= width
            #thickness is the whole width of each zone
            return self._geometry[zone][2]
        else:
            raise RuntimeError("Geometry not implemented!")
    
    def _computeMetallicity(self,zone):
        #This function is useful in case you give particular elements (C,N,O,...)
        if self._param_element['Z']['abundance'][zone] != None:
            Z = 0.0
            for symbol in self._param_element:
                if symbol != 'H' and symbol != 'He' and symbol != 'Z':
                    Xi = self._param_element[symbol]['abundance'][zone]
                    if Xi != None:
                        Z += Xi
            return Z
        else:
            return self._param_element['Z']['abundance'][zone]            
        
    def _computeHydrogenFraction(self,zone):
        X = None
        if self._param_element['He']['abundance'][zone] != None: #You gave Z or particular elements
            if self._param_element['Z']['abundance'][zone] != None: #You gave particular elements
                X = 1.0 - self._param_element['He']['abundance'][zone] - self._computeMetallicity(zone)
            else: #You gave metals
                X = 1.0 - self._param_element['He']['abundance'][zone] - self._param_element['Z']['abundance'][zone]
        return X
    
    def _writeSourceHeader(self,filename,wv,L):
        #filename.write("# Specific luminosity of this gas \n")
        filename.write("# Column 1: wavelength (nm) \n")
        filename.write("# Column 2: specific luminosity (erg/s) \n")
        filename.write("# Normalization wavelength "+str(wv)+" \n")
        filename.write("# nuLnu_Value "+str(L)+" \n")
    
    def _writeOpacityHeader(self,filename,mass):
        #filename.write("# extinction coefficient and albedo for a gas with width ="+str(width)+" pc \n")
        filename.write("# Column 1: wavelength (nm) \n")
        filename.write("# Column 2: extinction mass coefficient (cm2/g) \n")
        filename.write("# Column 3: albedo (1) \n")
        filename.write("# Column 4: scattering asymmetry parameter (1) \n")
        filename.write("# region mass "+str(mass)+" \n")
    
    def _writeNumeric(self,zone):
        if len(str(zone)) > 3:
            raise RuntimeError("Too many zones!")
        else:
            return str(zone).zfill(3)
    
    def _writeEmissionFile(self, zone, norm, wavelength, luminosity):
        #norm is the value of nuLnu at a fixed wavelength. The format is = [wavelength,nuLnu]
        
        output = open("GasSource_"+self._writeNumeric(zone)+".stab",'w')
        self._writeSourceHeader(output,norm[0],norm[1])
        for i in range(0,len(wavelength)):
            output.write(str(wavelength[i])+" "+str(luminosity[i])+" \n")
        
        output.close()
    
    def _writeOpacityFile(self, zone, norm, wavelength, extinction, albedo):
        #norm is the mass of the whole region, is a number in Solar masses
        
        output = open("MeanFileGasMix_"+self._writeNumeric(zone)+".stab",'w')
        self._writeOpacityHeader(output,norm)
        for i in range(0,len(wavelength)):
            output.write(str(wavelength[i])+" "+str(extinction[i])+" "+str(albedo[i])+" 0.0 \n")
        
        output.close()
    
        
    def GenerateCloudyFiles(self,Jfilename):
        '''
        This script reads the file generated with 'MeanIntensityAtPositions' probe,
        and generates a readable input for cloudy
        '''
        
        #I keep these variables due to compatibility with previous code
        n_digits = self._n_digits
        useIntensity = self._use_intensity_command_in_cloudy 
                                #If True, it will use the cloudy intensity at range
                                #Otherwise, it will use nuf(nu) X at Y (Ryd)
        wl_nuF = self._wavelength_norm # used if above is false
        
        #Read file
        file = open(Jfilename,'r')
        wavelength = []
        x = []
        y = []
        z = []
        nuJnu = []
        while True:
            line = file.readline()
            if not line: #EoF
                break
            line_data = line.split()
            
            if line_data[0] == '#':
                #Here we colect the wavelengths.
                #The structure of the skirt output is
                #Column 1: lambda*J_lambda at lambda = 0.0001 micron (W/m2/sr)
                #If we split line in line_data, the only element that can be
                #converted to a float is 0.0001, which is the wavelength
                for element in line_data:
                    try:
                        wavelength.append(float(element))
                    except:
                        continue
            else:
                nuJnu.append([])
                #First 3 columns are x,y,z
                x.append(float(line_data[0]))
                y.append(float(line_data[1]))
                z.append(float(line_data[2]))
                for i in range(3,len(line_data)):
                    nuJnu[-1].append(float(line_data[i]))
        file.close()
        
        x = np.array(x)
        y = np.array(y)
        z = np.array(z)
        #Also flip next arrays, as cloudy wants it in opposite order
        #wavelength = np.flip(np.array(wavelength)) * microns_TO_nm #in nm
        #nuJnu = np.fliplr(np.array(nuJnu))
        wavelength = np.array(wavelength) * self.microns_TO_nm #in nm
        nuJnu = np.array(nuJnu) * self.W_per_m2_TO_erg_per_cm2
        
        #Create the sed files
        outputfiles = self._sedFiles
        #make sure that the order is respected, file 1 is for position 1 and so on
        '''
        The number of outputs are tuned in the number of lines in "meanIntensity_positions" file variable.
        If you do not want problems, they MUST match both the number of zones and the order:
            file 1 is for first UNCOMMENTED (i.e: no #) line 1, and so on
        Extra outputs for J may be useful as well, and they are the following lines AFTER THE ZONES.
        They will be labelled as 'extra_Xpc.sed','extra_Ypc.sed' and so on
        '''
        if len(nuJnu) < len(outputfiles):
            raise RuntimeError("Number of outputs does not match!")
        for i in range(0,len(nuJnu)):
            R = np.sqrt(x[i]*x[i] + y[i]*y[i] + z[i]*z[i])
            fluxfile = None
            if i < len(outputfiles):
                fluxfile = open(outputfiles[i],'w')
            else:
                #W.I.P. Change 'extra' for the same name as outputfiles, but with the different R
                fluxfile = open("extra_"+str(R)+"pc.sed",'w')
            #fluxfile.write("# nuFnu at "+str(R)+" pc \n")
            fluxfile.write("# column 1: wavelength (nm) \n")
            fluxfile.write("# column 2: 4pi*nu*J_nu (erg/cm2/s) \n")
            if useIntensity:
                #Control_value is the integral at wavelengths of intensity
                total_J = np.trapz(nuJnu[i]/wavelength,wavelength)
                fluxfile.write("# intensity "+str(self.round_to(n_digits,np.log10(4.0*np.pi*total_J)))+" range "+str(wavelength[0])+" to "+str(wavelength[-1])+" nm \n")
            else:
                #Control value is nu*F at wl_nuF
                fixed_values = unk.findNormalization(wl_nuF,wavelength,nuJnu[i])
                fixed_wavelength = fixed_values[0]
                fixed_nuF = fixed_values[1]*4.0*np.pi #nuf(nu) command in cloudy actually asks for 4pi*nuJnu, see hazy 1
                #Above line may make coudy to fail. If that happens, cut the decimals in the respective cloudy input and repeat
                photon_energy = self.nm_to_Ryd(fixed_wavelength)
                try:
                    fluxfile.write("# nuf(nu) "+str(self.round_to(n_digits,np.log10(fixed_nuF)))+" at "+str(photon_energy)+" #("+str(fixed_wavelength)+" nm) \n")
                except OverflowError:
                    print(R,fixed_wavelength,fixed_nuF)
                    raise RuntimeError("Overflow error. Have you check that skirt grid boundaries is higher than your wanted output positions?")
                
            options_written = False
            for j in range(len(nuJnu[i])-1,0,-1):
                nuJnu_write = nuJnu[i][j]
                if nuJnu_write < 1e-300: nuJnu_write = 1e-300 #Cloudy cannot read 0.0
                fluxfile.write(str(self.round_to(n_digits,wavelength[j]))+" "+str(self.round_to(n_digits,4.0*np.pi*nuJnu_write)))
                if not options_written:
                    fluxfile.write(" nuFnu units nm \n")
                    options_written = True
                else:
                    fluxfile.write(" \n")
            fluxfile.close()
    
    #DEPRECIATED
    def _writeOpacityHeader_tauNormalization(self,filename,wv,tau): #DEPRECIATED
        #filename.write("# extinction coefficient and albedo for a gas with width ="+str(width)+" pc \n")
        filename.write("# Column 1: wavelength (nm) \n")
        filename.write("# Column 2: extinction mass coefficient (cm2/g) \n")
        filename.write("# Column 3: albedo (1) \n")
        filename.write("# Column 4: scattering asymmetry parameter (1) \n")
        filename.write("# Normalization wavelength "+str(wv)+" \n")
        filename.write("# tau_Value "+str(tau)+" \n")
    
    def _writeOpacityFile_tauNormalization(self, zone, norm, wavelength, extinction, albedo):
        #norm is the value of tau at a fixed wavelength. The format is = [wavelength,tau]
        
        output = open("MeanFileGasMix_"+self._writeNumeric(zone)+".stab",'w')
        self._writeOpacityHeader_tauNormalization(output,norm[0],norm[1])
        for i in range(0,len(wavelength)):
            output.write(str(wavelength[i])+" "+str(extinction[i])+" "+str(albedo[i])+" 0.0 \n")
        
        output.close()